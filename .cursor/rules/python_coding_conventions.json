{
  "name": "Python Coding Conventions",
  "version": "1.0.0",
  "description": "Python coding style guide based on PEP 8 and best practices",
  "rules": {
    "code_style": {
      "indentation": {
        "use": "4 spaces per indentation level",
        "never": "Tabs or mixing tabs and spaces",
        "max_line_length": 88,
        "note": "Follow Black formatter default (88 chars) or PEP 8 (79 chars)"
      },
      "line_breaks": {
        "blank_lines": {
          "top_level": "2 blank lines between functions and classes",
          "method_level": "1 blank line between methods",
          "logical_sections": "Use blank lines to separate logical sections"
        },
        "line_continuation": "Use parentheses for line continuation, not backslashes"
      },
      "imports": {
        "order": [
          "1. Standard library imports",
          "2. Related third party imports",
          "3. Local application/library specific imports"
        ],
        "format": "One import per line",
        "grouping": "Separate groups with blank lines",
        "wildcard": "Never use 'from module import *'",
        "absolute_vs_relative": "Prefer absolute imports over relative imports"
      }
    },
    "naming_conventions": {
      "variables": "Use snake_case (e.g., user_name, total_count)",
      "functions": "Use snake_case (e.g., calculate_total, get_user_data)",
      "classes": "Use PascalCase (e.g., UserAccount, DatabaseConnection)",
      "constants": "Use UPPER_SNAKE_CASE (e.g., MAX_RETRIES, API_BASE_URL)",
      "private": {
        "single_underscore": "Internal use (e.g., _internal_method)",
        "double_underscore": "Name mangling (e.g., __private_attr)",
        "note": "Avoid double underscore unless necessary for name mangling"
      },
      "special": {
        "dunder_methods": "Use double underscores (e.g., __init__, __str__)",
        "type_hints": "Use descriptive names for type variables (e.g., T, Key, Value)"
      }
    },
    "function_and_method_design": {
      "function_length": "Keep functions short and focused (ideally < 50 lines)",
      "parameters": {
        "max_parameters": "Limit to 3-4 parameters; use dataclasses or dicts for more",
        "default_values": "Mutable defaults should be None, then assign in function body",
        "example": "def func(items=None): items = items or []"
      },
      "return_values": {
        "consistency": "Return consistent types (don't mix None and values)",
        "early_returns": "Use early returns for guard clauses",
        "single_responsibility": "One function should do one thing"
      },
      "docstrings": {
        "style": "Use Google or NumPy style docstrings",
        "required_for": "All public functions, classes, and methods",
        "format": "Include description, parameters, return values, and exceptions"
      }
    },
    "class_design": {
      "organization": {
        "order": [
          "1. Class docstring",
          "2. __init__ method",
          "3. Public methods",
          "4. Private methods",
          "5. Class methods and static methods",
          "6. Properties"
        ]
      },
      "inheritance": {
        "prefer_composition": "Prefer composition over inheritance when possible",
        "multiple_inheritance": "Use sparingly and document clearly",
        "abstract_base_classes": "Use ABC for interfaces when appropriate"
      },
      "properties": "Use @property decorator for computed attributes",
      "dataclasses": "Use @dataclass for simple data containers (Python 3.7+)"
    },
    "error_handling": {
      "exceptions": {
        "be_specific": "Catch specific exceptions, not bare 'except:'",
        "order": "Catch more specific exceptions before general ones",
        "custom_exceptions": "Create custom exceptions for domain-specific errors"
      },
      "error_messages": "Provide clear, actionable error messages",
      "logging": "Use logging module instead of print statements for errors",
      "context_managers": "Use 'with' statements for resource management"
    },
    "type_hints": {
      "usage": "Use type hints for function parameters and return types",
      "optional": "Use Optional[Type] or Type | None for nullable types",
      "collections": "Use List[Type], Dict[Key, Value], Set[Type], Tuple[Type, ...]",
      "generics": "Use TypeVar and Generic for generic types",
      "typing_module": "Import from 'typing' module (Python 3.9+ can use built-in types)"
    },
    "code_quality": {
      "mutability": {
        "immutable_preferred": "Prefer immutable data structures when possible",
        "avoid_mutation": "Don't mutate function arguments unless necessary"
      },
      "comprehensions": {
        "list_comprehensions": "Use for simple transformations",
        "generator_expressions": "Use for large datasets to save memory",
        "readability": "Don't sacrifice readability for one-liners"
      },
      "lambda": "Use lambda for simple, one-line functions only",
      "decorators": "Use decorators for cross-cutting concerns (logging, caching, etc.)",
      "context_managers": "Use context managers for resource cleanup"
    },
    "testing": {
      "test_naming": "Test functions should start with 'test_'",
      "test_organization": "One test per behavior/requirement",
      "fixtures": "Use pytest fixtures for test setup and teardown",
      "mocking": "Mock external dependencies and I/O operations",
      "coverage": "Aim for >80% code coverage on critical paths"
    },
    "documentation": {
      "docstrings": {
        "modules": "Include module-level docstring explaining purpose",
        "classes": "Explain class purpose and usage",
        "functions": "Document parameters, return values, and exceptions"
      },
      "comments": {
        "why_not_what": "Explain 'why', not 'what' (code should be self-documenting)",
        "complex_logic": "Comment complex algorithms or business logic",
        "todo": "Use TODO comments for future improvements"
      },
      "type_hints": "Type hints serve as inline documentation"
    },
    "tools_and_formatters": {
      "formatter": "Use Black for code formatting",
      "linter": "Use flake8 or pylint for linting",
      "type_checker": "Use mypy for static type checking",
      "import_sorter": "Use isort for import organization",
      "pre_commit": "Set up pre-commit hooks for automated checks"
    },
    "performance": {
      "premature_optimization": "Don't optimize prematurely; profile first",
      "built_in_functions": "Prefer built-in functions and libraries",
      "generators": "Use generators for large datasets",
      "caching": "Use functools.lru_cache for expensive computations",
      "async": "Use async/await for I/O-bound operations"
    },
    "security": {
      "input_validation": "Always validate and sanitize user input",
      "secrets": "Never commit secrets or API keys to version control",
      "sql_injection": "Use parameterized queries, never string formatting",
      "eval_exec": "Avoid eval() and exec() with user input",
      "dependencies": "Keep dependencies updated and scan for vulnerabilities"
    }
  },
  "examples": {
    "good_function": {
      "code": "def calculate_total(items: List[Item], discount: float = 0.0) -> float:\n    \"\"\"Calculate total price with optional discount.\n    \n    Args:\n        items: List of items to calculate total for\n        discount: Discount percentage (0.0 to 1.0)\n    \n    Returns:\n        Total price after discount\n    \n    Raises:\n        ValueError: If discount is not between 0.0 and 1.0\n    \"\"\"\n    if not 0.0 <= discount <= 1.0:\n        raise ValueError(\"Discount must be between 0.0 and 1.0\")\n    \n    subtotal = sum(item.price for item in items)\n    return subtotal * (1 - discount)",
      "notes": [
        "Type hints for parameters and return value",
        "Default parameter value",
        "Comprehensive docstring",
        "Input validation",
        "Clear variable names",
        "Generator expression for efficiency"
      ]
    },
    "good_class": {
      "code": "class UserAccount:\n    \"\"\"Represents a user account in the system.\"\"\"\n    \n    def __init__(self, username: str, email: str) -> None:\n        self.username = username\n        self.email = email\n        self._is_active = True\n    \n    @property\n    def is_active(self) -> bool:\n        \"\"\"Check if account is active.\"\"\"\n        return self._is_active\n    \n    def deactivate(self) -> None:\n        \"\"\"Deactivate the user account.\"\"\"\n        self._is_active = False",
      "notes": [
        "PascalCase for class name",
        "Type hints in __init__",
        "Private attribute with underscore",
        "Property decorator for computed/controlled access"
      ]
    }
  }
}

